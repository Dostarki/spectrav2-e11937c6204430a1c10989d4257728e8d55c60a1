"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTransferSignature = generateTransferSignature;
exports.determineSignatureTransferType = determineSignatureTransferType;
exports.isValidSignatureAuth = isValidSignatureAuth;
const bs58_1 = __importDefault(require("bs58"));
/**
 * Generates a wallet signature for transfer authentication
 *
 * @param wallet - Wallet adapter with signMessage function
 * @param transferType - Type of transfer (zk_transfer, external_transfer, internal_transfer)
 * @returns Signature authentication object with signature and message
 * @throws Error if wallet doesn't support message signing
 */
async function generateTransferSignature(wallet, transferType = 'zk_transfer') {
    if (!wallet?.signMessage) {
        throw new Error('Wallet does not support message signing');
    }
    // Generate nonce and timestamp
    const nonce = generateRandomNonce();
    const timestamp = Math.floor(Date.now() / 1000); // Unix seconds
    // Build message: shadowpay:{transferType}:{nonce}:{timestamp}
    const message = `shadowpay:${transferType}:${nonce}:${timestamp}`;
    // Sign message
    const encodedMessage = new TextEncoder().encode(message);
    const signatureBytes = await wallet.signMessage(encodedMessage);
    const signature = bs58_1.default.encode(signatureBytes);
    return {
        sender_signature: signature,
        signature_message: message,
    };
}
/**
 * Generates a random nonce for signature authentication
 * Uses crypto.randomUUID() if available, otherwise generates a random string
 */
function generateRandomNonce() {
    // Check if crypto.randomUUID is available (browser or Node 16+)
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
        return crypto.randomUUID();
    }
    // Fallback for older Node.js versions
    if (typeof require !== 'undefined') {
        try {
            const nodeCrypto = require('crypto');
            return nodeCrypto.randomUUID();
        }
        catch {
            // If crypto module not available, generate random string
        }
    }
    // Fallback: generate random string
    return Math.random().toString(36).substring(2) + Date.now().toString(36);
}
/**
 * Determines the transfer type for signature authentication based on transfer parameters
 */
function determineSignatureTransferType(isInternal) {
    return isInternal ? 'internal_transfer' : 'external_transfer';
}
/**
 * Validates that a signature auth object has the required fields
 */
function isValidSignatureAuth(auth) {
    return (auth &&
        typeof auth === 'object' &&
        typeof auth.sender_signature === 'string' &&
        typeof auth.signature_message === 'string' &&
        auth.sender_signature.length > 0 &&
        auth.signature_message.length > 0);
}
//# sourceMappingURL=auth.js.map