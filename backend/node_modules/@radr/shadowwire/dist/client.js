"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShadowWireClient = void 0;
const constants_1 = require("./constants");
const tokens_1 = require("./tokens");
const utils_1 = require("./utils");
const errors_1 = require("./errors");
const zkProofs_1 = require("./zkProofs");
const auth_1 = require("./auth");
class ShadowWireClient {
    constructor(config = {}) {
        this.apiKey = config.apiKey;
        this.apiBaseUrl = config.apiBaseUrl || constants_1.DEFAULT_API_BASE_URL;
        this.network = config.network || constants_1.DEFAULT_NETWORK;
        this.debug = config.debug || false;
    }
    async getBalance(wallet, token) {
        (0, utils_1.validateSolanaAddress)(wallet);
        let url = `${this.apiBaseUrl}/pool/balance/${wallet}`;
        if (token) {
            const tokenMint = tokens_1.TokenUtils.getTokenMint(token);
            if (tokenMint !== 'Native') {
                url += `?token_mint=${tokenMint}`;
            }
        }
        return (0, utils_1.makeHttpRequest)(url, 'GET', this.apiKey, undefined, this.debug);
    }
    async deposit(request) {
        (0, utils_1.validateSolanaAddress)(request.wallet);
        if (request.amount <= 0) {
            throw new errors_1.InvalidAmountError('Deposit amount must be greater than zero');
        }
        return (0, utils_1.makeHttpRequest)(`${this.apiBaseUrl}/pool/deposit`, 'POST', this.apiKey, request, this.debug);
    }
    async withdraw(request) {
        (0, utils_1.validateSolanaAddress)(request.wallet);
        if (request.amount <= 0) {
            throw new errors_1.InvalidAmountError('Withdrawal amount must be greater than zero');
        }
        return (0, utils_1.makeHttpRequest)(`${this.apiBaseUrl}/pool/withdraw`, 'POST', this.apiKey, request, this.debug);
    }
    async uploadProof(request, wallet) {
        (0, utils_1.validateSolanaAddress)(request.sender_wallet);
        if (request.amount <= 0) {
            throw new errors_1.InvalidAmountError('Amount must be greater than zero');
        }
        let requestData = { ...request };
        // Generate signature if wallet provided
        if (wallet?.signMessage) {
            const sigAuth = await (0, auth_1.generateTransferSignature)(wallet, 'zk_transfer');
            requestData = {
                ...requestData,
                ...sigAuth,
            };
        }
        return (0, utils_1.makeHttpRequest)(`${this.apiBaseUrl}/zk/upload-proof`, 'POST', this.apiKey, requestData, this.debug);
    }
    async externalTransfer(request, wallet) {
        (0, utils_1.validateSolanaAddress)(request.sender_wallet);
        (0, utils_1.validateSolanaAddress)(request.recipient_wallet);
        if (request.sender_wallet === request.recipient_wallet) {
            throw new errors_1.TransferError('Cannot transfer to yourself');
        }
        let requestData = { ...request };
        // Generate signature if wallet provided
        if (wallet?.signMessage) {
            const sigAuth = await (0, auth_1.generateTransferSignature)(wallet, 'external_transfer');
            requestData = {
                ...requestData,
                ...sigAuth,
            };
        }
        return (0, utils_1.makeHttpRequest)(`${this.apiBaseUrl}/zk/external-transfer`, 'POST', this.apiKey, requestData, this.debug);
    }
    async internalTransfer(request, wallet) {
        (0, utils_1.validateSolanaAddress)(request.sender_wallet);
        (0, utils_1.validateSolanaAddress)(request.recipient_wallet);
        if (request.sender_wallet === request.recipient_wallet) {
            throw new errors_1.TransferError('Cannot transfer to yourself');
        }
        let requestData = { ...request };
        // Generate signature if wallet provided
        if (wallet?.signMessage) {
            const sigAuth = await (0, auth_1.generateTransferSignature)(wallet, 'internal_transfer');
            requestData = {
                ...requestData,
                ...sigAuth,
            };
        }
        try {
            return await (0, utils_1.makeHttpRequest)(`${this.apiBaseUrl}/zk/internal-transfer`, 'POST', this.apiKey, requestData, this.debug);
        }
        catch (error) {
            if (error.message?.includes('not found') || error.message?.includes('Recipient')) {
                throw new errors_1.RecipientNotFoundError(request.recipient_wallet);
            }
            throw error;
        }
    }
    async transfer(request) {
        (0, utils_1.validateSolanaAddress)(request.sender);
        (0, utils_1.validateSolanaAddress)(request.recipient);
        if (request.sender === request.recipient) {
            throw new errors_1.TransferError('Cannot transfer to yourself');
        }
        if (request.amount <= 0) {
            throw new errors_1.InvalidAmountError('Transfer amount must be greater than zero');
        }
        const amountSmallestUnit = tokens_1.TokenUtils.toSmallestUnit(request.amount, request.token);
        const nonce = (0, utils_1.generateNonce)();
        const tokenMint = tokens_1.TokenUtils.getTokenMint(request.token);
        const token = tokenMint === 'Native' ? 'SOL' : tokenMint;
        const proofResult = await this.uploadProof({
            sender_wallet: request.sender,
            token: token,
            amount: amountSmallestUnit,
            nonce: nonce,
        });
        const relayerFee = Math.floor(amountSmallestUnit * 0.01);
        if (request.type === 'internal') {
            const internalResult = await this.internalTransfer({
                sender_wallet: request.sender,
                recipient_wallet: request.recipient,
                token: token,
                nonce: proofResult.nonce,
                relayer_fee: relayerFee,
            });
            return {
                success: internalResult.success,
                tx_signature: internalResult.tx_signature,
                amount_sent: null,
                amount_hidden: true,
                proof_pda: internalResult.proof_pda,
            };
        }
        else {
            const externalResult = await this.externalTransfer({
                sender_wallet: request.sender,
                recipient_wallet: request.recipient,
                token: token,
                nonce: proofResult.nonce,
                relayer_fee: relayerFee,
            });
            return {
                success: externalResult.success,
                tx_signature: externalResult.tx_signature,
                amount_sent: externalResult.amount_sent,
                amount_hidden: false,
                proof_pda: externalResult.proof_pda,
            };
        }
    }
    async transferWithClientProofs(request) {
        (0, utils_1.validateSolanaAddress)(request.sender);
        (0, utils_1.validateSolanaAddress)(request.recipient);
        if (request.sender === request.recipient) {
            throw new errors_1.TransferError('Cannot transfer to yourself');
        }
        if (request.amount <= 0) {
            throw new errors_1.InvalidAmountError('Transfer amount must be greater than zero');
        }
        if (!(0, zkProofs_1.isWASMSupported)()) {
            throw new errors_1.TransferError('WebAssembly not supported. Use transfer() method for backend proof generation.');
        }
        const amountSmallestUnit = tokens_1.TokenUtils.toSmallestUnit(request.amount, request.token);
        let proof;
        if (request.customProof) {
            proof = request.customProof;
        }
        else {
            await (0, zkProofs_1.initWASM)();
            proof = await (0, zkProofs_1.generateRangeProof)(amountSmallestUnit, 64);
        }
        const nonce = (0, utils_1.generateNonce)();
        const tokenMint = tokens_1.TokenUtils.getTokenMint(request.token);
        const token = tokenMint === 'Native' ? 'SOL' : tokenMint;
        const proofResult = await this.uploadProof({
            sender_wallet: request.sender,
            token: token,
            amount: amountSmallestUnit,
            nonce: nonce,
        }, request.wallet);
        const relayerFee = Math.floor(amountSmallestUnit * 0.01);
        if (request.type === 'internal') {
            const internalResult = await this.internalTransfer({
                sender_wallet: request.sender,
                recipient_wallet: request.recipient,
                token: token,
                nonce: proofResult.nonce,
                relayer_fee: relayerFee,
            }, request.wallet);
            return {
                success: internalResult.success,
                tx_signature: internalResult.tx_signature,
                amount_sent: null,
                amount_hidden: true,
                proof_pda: internalResult.proof_pda,
            };
        }
        else {
            const externalResult = await this.externalTransfer({
                sender_wallet: request.sender,
                recipient_wallet: request.recipient,
                token: token,
                nonce: proofResult.nonce,
                relayer_fee: relayerFee,
            }, request.wallet);
            return {
                success: externalResult.success,
                tx_signature: externalResult.tx_signature,
                amount_sent: externalResult.amount_sent,
                amount_hidden: false,
                proof_pda: externalResult.proof_pda,
            };
        }
    }
    async generateProofLocally(amount, token) {
        const amountSmallestUnit = tokens_1.TokenUtils.toSmallestUnit(amount, token);
        await (0, zkProofs_1.initWASM)();
        return (0, zkProofs_1.generateRangeProof)(amountSmallestUnit, 64);
    }
    async authorizeSpending(request) {
        (0, utils_1.validateSolanaAddress)(request.wallet);
        (0, utils_1.validateSolanaAddress)(request.spender);
        if (request.amount <= 0) {
            throw new errors_1.InvalidAmountError('Authorization amount must be greater than zero');
        }
        return (0, utils_1.makeHttpRequest)(`${this.apiBaseUrl}/authorize-spending`, 'POST', this.apiKey, request, this.debug);
    }
    async revokeAuthorization(request) {
        (0, utils_1.validateSolanaAddress)(request.wallet);
        return (0, utils_1.makeHttpRequest)(`${this.apiBaseUrl}/revoke-authorization`, 'POST', this.apiKey, request, this.debug);
    }
    async getMyAuthorizations(wallet) {
        (0, utils_1.validateSolanaAddress)(wallet);
        return (0, utils_1.makeHttpRequest)(`${this.apiBaseUrl}/my-authorizations/${wallet}`, 'GET', this.apiKey, undefined, this.debug);
    }
}
exports.ShadowWireClient = ShadowWireClient;
//# sourceMappingURL=client.js.map